"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recipes/[id]/[step]/page",{

/***/ "(app-pages-browser)/./lib/color.ts":
/*!**********************!*\
  !*** ./lib/color.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeImageAgainstExpected: function() { return /* binding */ analyzeImageAgainstExpected; },\n/* harmony export */   brightnessFromRgb: function() { return /* binding */ brightnessFromRgb; },\n/* harmony export */   computeCategory: function() { return /* binding */ computeCategory; },\n/* harmony export */   loadImageFromFile: function() { return /* binding */ loadImageFromFile; }\n/* harmony export */ });\nconst MAX_CANVAS_SIZE = 600;\nconst clamp = (val, min, max)=>Math.max(min, Math.min(max, val));\nconst brightnessFromRgb = (r, g, b)=>(0.299 * r + 0.587 * g + 0.114 * b) / 255;\nasync function loadImageFromFile(file) {\n    const dataUrl = await readFileAsDataUrl(file);\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>resolve(img);\n        img.onerror = reject;\n        img.src = dataUrl;\n    });\n}\nasync function readFileAsDataUrl(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(file);\n    });\n}\nfunction getCanvasContext(img) {\n    const scale = Math.min(1, MAX_CANVAS_SIZE / Math.max(img.width, img.height));\n    const w = Math.max(1, Math.round(img.width * scale));\n    const h = Math.max(1, Math.round(img.height * scale));\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) throw new Error(\"Canvas is not supported.\");\n    ctx.drawImage(img, 0, 0, w, h);\n    return ctx;\n}\n/**\n * Calculate local color variance around a pixel to identify areas with detail (food) vs uniform areas (pan/counter)\n */ function getLocalVariance(imageData, x, y, width, height) {\n    let radius = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 3;\n    const { data } = imageData;\n    const colors = [];\n    for(let dy = -radius; dy <= radius; dy++){\n        for(let dx = -radius; dx <= radius; dx++){\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                const idx = (ny * width + nx) * 4;\n                const brightness = brightnessFromRgb(data[idx], data[idx + 1], data[idx + 2]);\n                colors.push(brightness);\n            }\n        }\n    }\n    if (colors.length < 2) return 0;\n    const mean = colors.reduce((a, b)=>a + b, 0) / colors.length;\n    const variance = colors.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / colors.length;\n    return variance;\n}\n/**\n * Calculate edge strength using simple gradient (Sobel-like)\n */ function getEdgeStrength(imageData, x, y, width, height) {\n    const { data } = imageData;\n    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) return 0;\n    const getBrightness = (nx, ny)=>{\n        const idx = (ny * width + nx) * 4;\n        return brightnessFromRgb(data[idx], data[idx + 1], data[idx + 2]);\n    };\n    // Simple gradient calculation\n    const gx = getBrightness(x + 1, y) - getBrightness(x - 1, y);\n    const gy = getBrightness(x, y + 1) - getBrightness(x, y - 1);\n    return Math.sqrt(gx * gx + gy * gy);\n}\n/**\n * Calculate center distance weight (pixels closer to center get higher weight)\n */ function getCenterWeight(x, y, width, height) {\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n    // Weight decreases from 1.0 at center to ~0.3 at edges\n    return Math.max(0.3, 1.0 - dist / maxDist * 0.7);\n}\n/**\n * Compute weighted average focusing on food areas (center, high variance, edges)\n */ function computeAverage(imageData) {\n    const { data, width, height } = imageData;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let totalWeight = 0;\n    // Sample every 2nd pixel for performance (can adjust)\n    const step = 2;\n    for(let y = 0; y < height; y += step){\n        for(let x = 0; x < width; x += step){\n            const idx = (y * width + x) * 4;\n            const pixelR = data[idx];\n            const pixelG = data[idx + 1];\n            const pixelB = data[idx + 2];\n            // Calculate weights\n            const centerWeight = getCenterWeight(x, y, width, height);\n            const variance = getLocalVariance(imageData, x, y, width, height);\n            const edgeStrength = getEdgeStrength(imageData, x, y, width, height);\n            // Normalize variance and edge strength (0-1 range)\n            const varianceWeight = Math.min(1.0, variance * 10); // Scale variance\n            const edgeWeight = Math.min(1.0, edgeStrength * 2); // Scale edge strength\n            // Combine weights: prefer center, high variance (food detail), and edges\n            // This filters out uniform areas like empty pans and counters\n            const combinedWeight = centerWeight * (0.5 + 0.3 * varianceWeight + 0.2 * edgeWeight);\n            r += pixelR * combinedWeight;\n            g += pixelG * combinedWeight;\n            b += pixelB * combinedWeight;\n            totalWeight += combinedWeight;\n        }\n    }\n    if (totalWeight === 0) {\n        // Fallback to simple average if no weights\n        return computeSimpleAverage(imageData);\n    }\n    return {\n        r: Math.round(r / totalWeight),\n        g: Math.round(g / totalWeight),\n        b: Math.round(b / totalWeight)\n    };\n}\n/**\n * Fallback: simple average of all pixels\n */ function computeSimpleAverage(imageData) {\n    const { data } = imageData;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    const totalPixels = data.length / 4;\n    for(let i = 0; i < data.length; i += 4){\n        r += data[i];\n        g += data[i + 1];\n        b += data[i + 2];\n    }\n    return {\n        r: Math.round(r / totalPixels),\n        g: Math.round(g / totalPixels),\n        b: Math.round(b / totalPixels)\n    };\n}\nfunction computeCategory(delta, tolerance) {\n    if (Math.abs(delta) <= tolerance * 0.4) return \"match\";\n    if (Math.abs(delta) <= tolerance * 0.9) return \"close\";\n    return \"off\";\n}\nfunction guidanceFromDeltas(deltaRgb, expected) {\n    const guidance = [];\n    const { brightnessRange } = expected;\n    const [minB, maxB] = brightnessRange;\n    if (deltaRgb.brightness < 0 && deltaRgb.brightness < minB - maxB) {\n        guidance.push(\"Looks too dark; add a splash of coconut milk/stock to lighten and stir.\");\n    } else if (deltaRgb.brightness > 0 && deltaRgb.brightness > maxB - minB) {\n        guidance.push(\"Looks too pale; add a small spoon of curry paste to deepen color.\");\n    }\n    if (deltaRgb.r > 15 && deltaRgb.g < -10) {\n        guidance.push(\"Too red; add a bit more coconut milk to balance.\");\n    }\n    if (deltaRgb.g > 15 && deltaRgb.r < -10) {\n        guidance.push(\"Too green/under-browned; add a spoon of paste or simmer a bit longer.\");\n    }\n    if (deltaRgb.b > 15) {\n        guidance.push(\"Too cool-toned; add a touch of coconut milk and stir to warm the tone.\");\n    }\n    if (deltaRgb.b < -15) {\n        guidance.push(\"Too warm-toned; balance with a splash of stock/coconut milk.\");\n    }\n    if (guidance.length === 0) guidance.push(\"Color is on track. Keep going!\");\n    return guidance;\n}\nasync function analyzeImageAgainstExpected(file, expected) {\n    const img = await loadImageFromFile(file);\n    const ctx = getCanvasContext(img);\n    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n    const average = computeAverage(imageData);\n    const brightness = brightnessFromRgb(average.r, average.g, average.b);\n    const delta = {\n        r: average.r - expected.avgRgb.r,\n        g: average.g - expected.avgRgb.g,\n        b: average.b - expected.avgRgb.b,\n        brightness: brightness - clamp((expected.brightnessRange[0] + expected.brightnessRange[1]) / 2, 0, 1)\n    };\n    const maxDelta = Math.max(Math.abs(delta.r), Math.abs(delta.g), Math.abs(delta.b));\n    const category = computeCategory(maxDelta, expected.tolerance);\n    const guidance = guidanceFromDeltas(delta, expected);\n    return {\n        average,\n        brightness,\n        delta,\n        category,\n        guidance\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUJUO0lBQzdCLE1BQU13QixZQUFZTCxJQUFJNkQsWUFBWSxDQUFDLEdBQUcsR0FBRzdELElBQUlILE1BQU0sQ0FBQ0wsS0FBSyxFQUFFUSxJQUFJSCxNQUFNLENBQUNKLE1BQU07SUFDNUUsTUFBTXFFLFVBQVUzQixlQUFlOUI7SUFDL0IsTUFBTVcsYUFBYTlDLGtCQUFrQjRGLFFBQVEzRixDQUFDLEVBQUUyRixRQUFRMUYsQ0FBQyxFQUFFMEYsUUFBUXpGLENBQUM7SUFFcEUsTUFBTTZFLFFBQVE7UUFDWi9FLEdBQUcyRixRQUFRM0YsQ0FBQyxHQUFHb0YsU0FBU1EsTUFBTSxDQUFDNUYsQ0FBQztRQUNoQ0MsR0FBRzBGLFFBQVExRixDQUFDLEdBQUdtRixTQUFTUSxNQUFNLENBQUMzRixDQUFDO1FBQ2hDQyxHQUFHeUYsUUFBUXpGLENBQUMsR0FBR2tGLFNBQVNRLE1BQU0sQ0FBQzFGLENBQUM7UUFDaEMyQyxZQUNFQSxhQUNBbkQsTUFDRSxDQUFDMEYsU0FBU0UsZUFBZSxDQUFDLEVBQUUsR0FBR0YsU0FBU0UsZUFBZSxDQUFDLEVBQUUsSUFBSSxHQUM5RCxHQUNBO0lBRU47SUFFQSxNQUFNTyxXQUFXL0YsS0FBS0QsR0FBRyxDQUFDQyxLQUFLbUYsR0FBRyxDQUFDRixNQUFNL0UsQ0FBQyxHQUFHRixLQUFLbUYsR0FBRyxDQUFDRixNQUFNOUUsQ0FBQyxHQUFHSCxLQUFLbUYsR0FBRyxDQUFDRixNQUFNN0UsQ0FBQztJQUNoRixNQUFNNEYsV0FBV2hCLGdCQUFnQmUsVUFBVVQsU0FBU0osU0FBUztJQUM3RCxNQUFNSyxXQUFXSCxtQkFBbUJILE9BQU9LO0lBRTNDLE9BQU87UUFBRU87UUFBUzlDO1FBQVlrQztRQUFPZTtRQUFVVDtJQUFTO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jb2xvci50cz8xZWJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBhcmlzb25SZXN1bHQsIENvbXBhcmlzb25DYXRlZ29yeSwgRXhwZWN0ZWRDb2xvclN0YXRzIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuY29uc3QgTUFYX0NBTlZBU19TSVpFID0gNjAwO1xuXG5jb25zdCBjbGFtcCA9ICh2YWw6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsKSk7XG5cbmV4cG9ydCBjb25zdCBicmlnaHRuZXNzRnJvbVJnYiA9IChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKSA9PlxuICAoMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiKSAvIDI1NTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUZyb21GaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+IHtcbiAgY29uc3QgZGF0YVVybCA9IGF3YWl0IHJlYWRGaWxlQXNEYXRhVXJsKGZpbGUpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XG4gICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgaW1nLnNyYyA9IGRhdGFVcmw7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZUFzRGF0YVVybChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKTtcbiAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0NvbnRleHQoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcbiAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbigxLCBNQVhfQ0FOVkFTX1NJWkUgLyBNYXRoLm1heChpbWcud2lkdGgsIGltZy5oZWlnaHQpKTtcbiAgY29uc3QgdyA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaW1nLndpZHRoICogc2NhbGUpKTtcbiAgY29uc3QgaCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaW1nLmhlaWdodCAqIHNjYWxlKSk7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoIWN0eCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgdywgaCk7XG4gIHJldHVybiBjdHg7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxvY2FsIGNvbG9yIHZhcmlhbmNlIGFyb3VuZCBhIHBpeGVsIHRvIGlkZW50aWZ5IGFyZWFzIHdpdGggZGV0YWlsIChmb29kKSB2cyB1bmlmb3JtIGFyZWFzIChwYW4vY291bnRlcilcbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxWYXJpYW5jZShcbiAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgcmFkaXVzOiBudW1iZXIgPSAzXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGRhdGEgfSA9IGltYWdlRGF0YTtcbiAgY29uc3QgY29sb3JzOiBudW1iZXJbXSA9IFtdO1xuICBcbiAgZm9yIChsZXQgZHkgPSAtcmFkaXVzOyBkeSA8PSByYWRpdXM7IGR5KyspIHtcbiAgICBmb3IgKGxldCBkeCA9IC1yYWRpdXM7IGR4IDw9IHJhZGl1czsgZHgrKykge1xuICAgICAgY29uc3QgbnggPSB4ICsgZHg7XG4gICAgICBjb25zdCBueSA9IHkgKyBkeTtcbiAgICAgIGlmIChueCA+PSAwICYmIG54IDwgd2lkdGggJiYgbnkgPj0gMCAmJiBueSA8IGhlaWdodCkge1xuICAgICAgICBjb25zdCBpZHggPSAobnkgKiB3aWR0aCArIG54KSAqIDQ7XG4gICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSBicmlnaHRuZXNzRnJvbVJnYihkYXRhW2lkeF0sIGRhdGFbaWR4ICsgMV0sIGRhdGFbaWR4ICsgMl0pO1xuICAgICAgICBjb2xvcnMucHVzaChicmlnaHRuZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGlmIChjb2xvcnMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIFxuICBjb25zdCBtZWFuID0gY29sb3JzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gY29sb3JzLmxlbmd0aDtcbiAgY29uc3QgdmFyaWFuY2UgPSBjb2xvcnMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgTWF0aC5wb3codmFsIC0gbWVhbiwgMiksIDApIC8gY29sb3JzLmxlbmd0aDtcbiAgcmV0dXJuIHZhcmlhbmNlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBlZGdlIHN0cmVuZ3RoIHVzaW5nIHNpbXBsZSBncmFkaWVudCAoU29iZWwtbGlrZSlcbiAqL1xuZnVuY3Rpb24gZ2V0RWRnZVN0cmVuZ3RoKFxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGRhdGEgfSA9IGltYWdlRGF0YTtcbiAgaWYgKHggPT09IDAgfHwgeCA9PT0gd2lkdGggLSAxIHx8IHkgPT09IDAgfHwgeSA9PT0gaGVpZ2h0IC0gMSkgcmV0dXJuIDA7XG4gIFxuICBjb25zdCBnZXRCcmlnaHRuZXNzID0gKG54OiBudW1iZXIsIG55OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBpZHggPSAobnkgKiB3aWR0aCArIG54KSAqIDQ7XG4gICAgcmV0dXJuIGJyaWdodG5lc3NGcm9tUmdiKGRhdGFbaWR4XSwgZGF0YVtpZHggKyAxXSwgZGF0YVtpZHggKyAyXSk7XG4gIH07XG4gIFxuICAvLyBTaW1wbGUgZ3JhZGllbnQgY2FsY3VsYXRpb25cbiAgY29uc3QgZ3ggPSBnZXRCcmlnaHRuZXNzKHggKyAxLCB5KSAtIGdldEJyaWdodG5lc3MoeCAtIDEsIHkpO1xuICBjb25zdCBneSA9IGdldEJyaWdodG5lc3MoeCwgeSArIDEpIC0gZ2V0QnJpZ2h0bmVzcyh4LCB5IC0gMSk7XG4gIHJldHVybiBNYXRoLnNxcnQoZ3ggKiBneCArIGd5ICogZ3kpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjZW50ZXIgZGlzdGFuY2Ugd2VpZ2h0IChwaXhlbHMgY2xvc2VyIHRvIGNlbnRlciBnZXQgaGlnaGVyIHdlaWdodClcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyV2VpZ2h0KHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGNlbnRlclggPSB3aWR0aCAvIDI7XG4gIGNvbnN0IGNlbnRlclkgPSBoZWlnaHQgLyAyO1xuICBjb25zdCBtYXhEaXN0ID0gTWF0aC5zcXJ0KGNlbnRlclggKiBjZW50ZXJYICsgY2VudGVyWSAqIGNlbnRlclkpO1xuICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KCh4IC0gY2VudGVyWCkgKiogMiArICh5IC0gY2VudGVyWSkgKiogMik7XG4gIC8vIFdlaWdodCBkZWNyZWFzZXMgZnJvbSAxLjAgYXQgY2VudGVyIHRvIH4wLjMgYXQgZWRnZXNcbiAgcmV0dXJuIE1hdGgubWF4KDAuMywgMS4wIC0gKGRpc3QgLyBtYXhEaXN0KSAqIDAuNyk7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB3ZWlnaHRlZCBhdmVyYWdlIGZvY3VzaW5nIG9uIGZvb2QgYXJlYXMgKGNlbnRlciwgaGlnaCB2YXJpYW5jZSwgZWRnZXMpXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdmVyYWdlKGltYWdlRGF0YTogSW1hZ2VEYXRhKSB7XG4gIGNvbnN0IHsgZGF0YSwgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2VEYXRhO1xuICBsZXQgciA9IDA7XG4gIGxldCBnID0gMDtcbiAgbGV0IGIgPSAwO1xuICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuICBcbiAgLy8gU2FtcGxlIGV2ZXJ5IDJuZCBwaXhlbCBmb3IgcGVyZm9ybWFuY2UgKGNhbiBhZGp1c3QpXG4gIGNvbnN0IHN0ZXAgPSAyO1xuICBcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gc3RlcCkge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gc3RlcCkge1xuICAgICAgY29uc3QgaWR4ID0gKHkgKiB3aWR0aCArIHgpICogNDtcbiAgICAgIGNvbnN0IHBpeGVsUiA9IGRhdGFbaWR4XTtcbiAgICAgIGNvbnN0IHBpeGVsRyA9IGRhdGFbaWR4ICsgMV07XG4gICAgICBjb25zdCBwaXhlbEIgPSBkYXRhW2lkeCArIDJdO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0c1xuICAgICAgY29uc3QgY2VudGVyV2VpZ2h0ID0gZ2V0Q2VudGVyV2VpZ2h0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdmFyaWFuY2UgPSBnZXRMb2NhbFZhcmlhbmNlKGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBlZGdlU3RyZW5ndGggPSBnZXRFZGdlU3RyZW5ndGgoaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gTm9ybWFsaXplIHZhcmlhbmNlIGFuZCBlZGdlIHN0cmVuZ3RoICgwLTEgcmFuZ2UpXG4gICAgICBjb25zdCB2YXJpYW5jZVdlaWdodCA9IE1hdGgubWluKDEuMCwgdmFyaWFuY2UgKiAxMCk7IC8vIFNjYWxlIHZhcmlhbmNlXG4gICAgICBjb25zdCBlZGdlV2VpZ2h0ID0gTWF0aC5taW4oMS4wLCBlZGdlU3RyZW5ndGggKiAyKTsgLy8gU2NhbGUgZWRnZSBzdHJlbmd0aFxuICAgICAgXG4gICAgICAvLyBDb21iaW5lIHdlaWdodHM6IHByZWZlciBjZW50ZXIsIGhpZ2ggdmFyaWFuY2UgKGZvb2QgZGV0YWlsKSwgYW5kIGVkZ2VzXG4gICAgICAvLyBUaGlzIGZpbHRlcnMgb3V0IHVuaWZvcm0gYXJlYXMgbGlrZSBlbXB0eSBwYW5zIGFuZCBjb3VudGVyc1xuICAgICAgY29uc3QgY29tYmluZWRXZWlnaHQgPSBjZW50ZXJXZWlnaHQgKiAoMC41ICsgMC4zICogdmFyaWFuY2VXZWlnaHQgKyAwLjIgKiBlZGdlV2VpZ2h0KTtcbiAgICAgIFxuICAgICAgciArPSBwaXhlbFIgKiBjb21iaW5lZFdlaWdodDtcbiAgICAgIGcgKz0gcGl4ZWxHICogY29tYmluZWRXZWlnaHQ7XG4gICAgICBiICs9IHBpeGVsQiAqIGNvbWJpbmVkV2VpZ2h0O1xuICAgICAgdG90YWxXZWlnaHQgKz0gY29tYmluZWRXZWlnaHQ7XG4gICAgfVxuICB9XG4gIFxuICBpZiAodG90YWxXZWlnaHQgPT09IDApIHtcbiAgICAvLyBGYWxsYmFjayB0byBzaW1wbGUgYXZlcmFnZSBpZiBubyB3ZWlnaHRzXG4gICAgcmV0dXJuIGNvbXB1dGVTaW1wbGVBdmVyYWdlKGltYWdlRGF0YSk7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5yb3VuZChyIC8gdG90YWxXZWlnaHQpLFxuICAgIGc6IE1hdGgucm91bmQoZyAvIHRvdGFsV2VpZ2h0KSxcbiAgICBiOiBNYXRoLnJvdW5kKGIgLyB0b3RhbFdlaWdodClcbiAgfTtcbn1cblxuLyoqXG4gKiBGYWxsYmFjazogc2ltcGxlIGF2ZXJhZ2Ugb2YgYWxsIHBpeGVsc1xuICovXG5mdW5jdGlvbiBjb21wdXRlU2ltcGxlQXZlcmFnZShpbWFnZURhdGE6IEltYWdlRGF0YSkge1xuICBjb25zdCB7IGRhdGEgfSA9IGltYWdlRGF0YTtcbiAgbGV0IHIgPSAwO1xuICBsZXQgZyA9IDA7XG4gIGxldCBiID0gMDtcbiAgY29uc3QgdG90YWxQaXhlbHMgPSBkYXRhLmxlbmd0aCAvIDQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIHIgKz0gZGF0YVtpXTtcbiAgICBnICs9IGRhdGFbaSArIDFdO1xuICAgIGIgKz0gZGF0YVtpICsgMl07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiBNYXRoLnJvdW5kKHIgLyB0b3RhbFBpeGVscyksXG4gICAgZzogTWF0aC5yb3VuZChnIC8gdG90YWxQaXhlbHMpLFxuICAgIGI6IE1hdGgucm91bmQoYiAvIHRvdGFsUGl4ZWxzKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNhdGVnb3J5KGRlbHRhOiBudW1iZXIsIHRvbGVyYW5jZTogbnVtYmVyKTogQ29tcGFyaXNvbkNhdGVnb3J5IHtcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA8PSB0b2xlcmFuY2UgKiAwLjQpIHJldHVybiBcIm1hdGNoXCI7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPD0gdG9sZXJhbmNlICogMC45KSByZXR1cm4gXCJjbG9zZVwiO1xuICByZXR1cm4gXCJvZmZcIjtcbn1cblxuZnVuY3Rpb24gZ3VpZGFuY2VGcm9tRGVsdGFzKFxuICBkZWx0YVJnYjogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBicmlnaHRuZXNzOiBudW1iZXIgfSxcbiAgZXhwZWN0ZWQ6IEV4cGVjdGVkQ29sb3JTdGF0c1xuKTogc3RyaW5nW10ge1xuICBjb25zdCBndWlkYW5jZTogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgeyBicmlnaHRuZXNzUmFuZ2UgfSA9IGV4cGVjdGVkO1xuICBjb25zdCBbbWluQiwgbWF4Ql0gPSBicmlnaHRuZXNzUmFuZ2U7XG5cbiAgaWYgKGRlbHRhUmdiLmJyaWdodG5lc3MgPCAwICYmIGRlbHRhUmdiLmJyaWdodG5lc3MgPCBtaW5CIC0gbWF4Qikge1xuICAgIGd1aWRhbmNlLnB1c2goXCJMb29rcyB0b28gZGFyazsgYWRkIGEgc3BsYXNoIG9mIGNvY29udXQgbWlsay9zdG9jayB0byBsaWdodGVuIGFuZCBzdGlyLlwiKTtcbiAgfSBlbHNlIGlmIChkZWx0YVJnYi5icmlnaHRuZXNzID4gMCAmJiBkZWx0YVJnYi5icmlnaHRuZXNzID4gbWF4QiAtIG1pbkIpIHtcbiAgICBndWlkYW5jZS5wdXNoKFwiTG9va3MgdG9vIHBhbGU7IGFkZCBhIHNtYWxsIHNwb29uIG9mIGN1cnJ5IHBhc3RlIHRvIGRlZXBlbiBjb2xvci5cIik7XG4gIH1cblxuICBpZiAoZGVsdGFSZ2IuciA+IDE1ICYmIGRlbHRhUmdiLmcgPCAtMTApIHtcbiAgICBndWlkYW5jZS5wdXNoKFwiVG9vIHJlZDsgYWRkIGEgYml0IG1vcmUgY29jb251dCBtaWxrIHRvIGJhbGFuY2UuXCIpO1xuICB9XG4gIGlmIChkZWx0YVJnYi5nID4gMTUgJiYgZGVsdGFSZ2IuciA8IC0xMCkge1xuICAgIGd1aWRhbmNlLnB1c2goXCJUb28gZ3JlZW4vdW5kZXItYnJvd25lZDsgYWRkIGEgc3Bvb24gb2YgcGFzdGUgb3Igc2ltbWVyIGEgYml0IGxvbmdlci5cIik7XG4gIH1cbiAgaWYgKGRlbHRhUmdiLmIgPiAxNSkge1xuICAgIGd1aWRhbmNlLnB1c2goXCJUb28gY29vbC10b25lZDsgYWRkIGEgdG91Y2ggb2YgY29jb251dCBtaWxrIGFuZCBzdGlyIHRvIHdhcm0gdGhlIHRvbmUuXCIpO1xuICB9XG4gIGlmIChkZWx0YVJnYi5iIDwgLTE1KSB7XG4gICAgZ3VpZGFuY2UucHVzaChcIlRvbyB3YXJtLXRvbmVkOyBiYWxhbmNlIHdpdGggYSBzcGxhc2ggb2Ygc3RvY2svY29jb251dCBtaWxrLlwiKTtcbiAgfVxuXG4gIGlmIChndWlkYW5jZS5sZW5ndGggPT09IDApIGd1aWRhbmNlLnB1c2goXCJDb2xvciBpcyBvbiB0cmFjay4gS2VlcCBnb2luZyFcIik7XG4gIHJldHVybiBndWlkYW5jZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVJbWFnZUFnYWluc3RFeHBlY3RlZChcbiAgZmlsZTogRmlsZSxcbiAgZXhwZWN0ZWQ6IEV4cGVjdGVkQ29sb3JTdGF0c1xuKTogUHJvbWlzZTxDb21wYXJpc29uUmVzdWx0PiB7XG4gIGNvbnN0IGltZyA9IGF3YWl0IGxvYWRJbWFnZUZyb21GaWxlKGZpbGUpO1xuICBjb25zdCBjdHggPSBnZXRDYW52YXNDb250ZXh0KGltZyk7XG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xuICBjb25zdCBhdmVyYWdlID0gY29tcHV0ZUF2ZXJhZ2UoaW1hZ2VEYXRhKTtcbiAgY29uc3QgYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3NGcm9tUmdiKGF2ZXJhZ2UuciwgYXZlcmFnZS5nLCBhdmVyYWdlLmIpO1xuXG4gIGNvbnN0IGRlbHRhID0ge1xuICAgIHI6IGF2ZXJhZ2UuciAtIGV4cGVjdGVkLmF2Z1JnYi5yLFxuICAgIGc6IGF2ZXJhZ2UuZyAtIGV4cGVjdGVkLmF2Z1JnYi5nLFxuICAgIGI6IGF2ZXJhZ2UuYiAtIGV4cGVjdGVkLmF2Z1JnYi5iLFxuICAgIGJyaWdodG5lc3M6XG4gICAgICBicmlnaHRuZXNzIC1cbiAgICAgIGNsYW1wKFxuICAgICAgICAoZXhwZWN0ZWQuYnJpZ2h0bmVzc1JhbmdlWzBdICsgZXhwZWN0ZWQuYnJpZ2h0bmVzc1JhbmdlWzFdKSAvIDIsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIClcbiAgfTtcblxuICBjb25zdCBtYXhEZWx0YSA9IE1hdGgubWF4KE1hdGguYWJzKGRlbHRhLnIpLCBNYXRoLmFicyhkZWx0YS5nKSwgTWF0aC5hYnMoZGVsdGEuYikpO1xuICBjb25zdCBjYXRlZ29yeSA9IGNvbXB1dGVDYXRlZ29yeShtYXhEZWx0YSwgZXhwZWN0ZWQudG9sZXJhbmNlKTtcbiAgY29uc3QgZ3VpZGFuY2UgPSBndWlkYW5jZUZyb21EZWx0YXMoZGVsdGEsIGV4cGVjdGVkKTtcblxuICByZXR1cm4geyBhdmVyYWdlLCBicmlnaHRuZXNzLCBkZWx0YSwgY2F0ZWdvcnksIGd1aWRhbmNlIH07XG59XG5cbiJdLCJuYW1lcyI6WyJNQVhfQ0FOVkFTX1NJWkUiLCJjbGFtcCIsInZhbCIsIm1pbiIsIm1heCIsIk1hdGgiLCJicmlnaHRuZXNzRnJvbVJnYiIsInIiLCJnIiwiYiIsImxvYWRJbWFnZUZyb21GaWxlIiwiZmlsZSIsImRhdGFVcmwiLCJyZWFkRmlsZUFzRGF0YVVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJnZXRDYW52YXNDb250ZXh0Iiwic2NhbGUiLCJ3aWR0aCIsImhlaWdodCIsInciLCJyb3VuZCIsImgiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiRXJyb3IiLCJkcmF3SW1hZ2UiLCJnZXRMb2NhbFZhcmlhbmNlIiwiaW1hZ2VEYXRhIiwieCIsInkiLCJyYWRpdXMiLCJkYXRhIiwiY29sb3JzIiwiZHkiLCJkeCIsIm54IiwibnkiLCJpZHgiLCJicmlnaHRuZXNzIiwicHVzaCIsImxlbmd0aCIsIm1lYW4iLCJyZWR1Y2UiLCJhIiwidmFyaWFuY2UiLCJzdW0iLCJwb3ciLCJnZXRFZGdlU3RyZW5ndGgiLCJnZXRCcmlnaHRuZXNzIiwiZ3giLCJneSIsInNxcnQiLCJnZXRDZW50ZXJXZWlnaHQiLCJjZW50ZXJYIiwiY2VudGVyWSIsIm1heERpc3QiLCJkaXN0IiwiY29tcHV0ZUF2ZXJhZ2UiLCJ0b3RhbFdlaWdodCIsInN0ZXAiLCJwaXhlbFIiLCJwaXhlbEciLCJwaXhlbEIiLCJjZW50ZXJXZWlnaHQiLCJlZGdlU3RyZW5ndGgiLCJ2YXJpYW5jZVdlaWdodCIsImVkZ2VXZWlnaHQiLCJjb21iaW5lZFdlaWdodCIsImNvbXB1dGVTaW1wbGVBdmVyYWdlIiwidG90YWxQaXhlbHMiLCJpIiwiY29tcHV0ZUNhdGVnb3J5IiwiZGVsdGEiLCJ0b2xlcmFuY2UiLCJhYnMiLCJndWlkYW5jZUZyb21EZWx0YXMiLCJkZWx0YVJnYiIsImV4cGVjdGVkIiwiZ3VpZGFuY2UiLCJicmlnaHRuZXNzUmFuZ2UiLCJtaW5CIiwibWF4QiIsImFuYWx5emVJbWFnZUFnYWluc3RFeHBlY3RlZCIsImdldEltYWdlRGF0YSIsImF2ZXJhZ2UiLCJhdmdSZ2IiLCJtYXhEZWx0YSIsImNhdGVnb3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/color.ts\n"));

/***/ })

});